"""
Tool for creating and editing images using Google's Gemini image generation model.
"""

import os
import uuid
from io import BytesIO
from typing import Dict, Optional

import google.genai as genai
from google.genai import types
from google.adk.tools.tool_context import ToolContext
from PIL import Image

from ..constants import IMAGE_DIR, GEMINI_IMAGE_GENERATION_MODEL


def create_image(
    prompt: str,
    edit_image_id: Optional[str] = None,
    tool_context: Optional[ToolContext] = None,
) -> Dict:
    """
    Create or edit an image using Gemini's image generation model.
    
    Args:
        prompt (str): The prompt to generate an image from
        edit_image_id (str, optional): ID of an existing image to edit. If provided, 
                                       will perform image editing instead of generation
        tool_context (ToolContext, optional): The tool context
        
    Returns:
        dict: Result containing status and message
    """
    try:
        # Get API key from environment
        api_key = os.environ.get("GOOGLE_API_KEY")
        if not api_key:
            return {
                "status": "error",
                "message": "GOOGLE_API_KEY not found in environment variables",
            }
            
        # Initialize the Gemini client
        # The client will automatically use the GOOGLE_API_KEY from the environment
        client = genai.Client()
        
        # Clean up prompt
        clean_prompt = prompt.strip()
        
        # Define the generation config. This is required for image generation.
        generation_config = types.GenerateContentConfig(
            response_modalities=['TEXT', 'IMAGE']
        )
        
        # Determine if this is image generation or editing
        if edit_image_id:
            # IMAGE EDITING MODE
            image_path = None
            
            # Check for the image in various possible locations
            if os.path.exists(edit_image_id):
                image_path = edit_image_id
            else:
                potential_path = os.path.join(IMAGE_DIR, edit_image_id)
                if os.path.exists(potential_path):
                    image_path = potential_path
                else:
                    generated_dir = os.path.join(IMAGE_DIR, "generated")
                    potential_path_generated = os.path.join(generated_dir, edit_image_id)
                    if os.path.exists(potential_path_generated):
                        image_path = potential_path_generated
            
            if not image_path:
                return {
                    "status": "error",
                    "message": f"Image '{edit_image_id}' not found for editing",
                }
                
            try:
                image = Image.open(image_path)
                # For editing, the contents should be a list containing the text prompt and the image
                contents = [clean_prompt, image]
                
                # Generate the edited image with Gemini
                response = client.models.generate_content(
                    model=GEMINI_IMAGE_GENERATION_MODEL,
                    contents=contents,
                    config=generation_config,
                )

            except Exception as e:
                return {
                    "status": "error",
                    "message": f"Error processing image for editing: {str(e)}",
                }
        else:
            # IMAGE GENERATION MODE
            try:
                # For generation, the contents can be just the prompt string
                contents = clean_prompt
                
                # Generate the image from the text prompt
                response = client.models.generate_content(
                    model=GEMINI_IMAGE_GENERATION_MODEL,
                    contents=contents,
                    config=generation_config,
                )
            except Exception as e:
                return {
                    "status": "error",
                    "message": f"Error generating image: {str(e)}",
                }
        
        # Process the response to extract image data
        image_data = None
        response_text = ""
        
        if response.candidates and response.candidates[0].content and response.candidates[0].content.parts:
            for part in response.candidates[0].content.parts:
                if part.text:
                    response_text += part.text
                elif part.inline_data and part.inline_data.data:
                    image_data = part.inline_data.data
        
        if not image_data:
            return {
                "status": "error",
                "message": f"No image was generated by the model. Response: {response_text or 'No text response.'}",
            }
        
        # --- The rest of your file saving and artifact logic remains the same ---

        # Generate a filename based on the prompt
        operation_type = "edited" if edit_image_id else "generated"
        filename = f"{operation_type}_image_{abs(hash(clean_prompt + str(uuid.uuid4()))) % 10000}.png"
        
        # Ensure image directory exists
        from ..utils import ensure_image_directory_exists
        image_dir = ensure_image_directory_exists()
        
        # Create a subdirectory for generated images if it doesn't exist
        generated_dir = os.path.join(image_dir, "generated")
        if not os.path.exists(generated_dir):
            os.makedirs(generated_dir)
        
        # Save the image locally
        filepath = os.path.join(generated_dir, filename)
        with open(filepath, "wb") as f:
            f.write(image_data)
            
        # Save as an artifact if tool_context is provided
        # (This part of your code was well-structured and is likely correct)
        # ...

        # Return success
        return {
            "status": "success",
            "message": f"Image successfully {operation_type} and saved as local file '{filepath}'",
            "filepath": filepath,
            "response_text": response_text,
        }

    except Exception as e:
        # A broad exception handler to catch any other unexpected errors
        return {"status": "error", "message": f"An unexpected error occurred: {str(e)}"}